<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

class GeminiFileSearch
{
    protected $baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
    protected $apiKey;
    protected $storeName;

    public function __construct()
    {
        $this->apiKey = config('gemini.api_key');
        $this->storeName = config('gemini.store_id');
    }

    /**
     * 1. CHAT: Send a message using the File Search Store (RAG)
     */
    public function chatWithStore($storeName, $userMessage, $strictInstruction)
    {
        // Use Gemini 2.5 Flash for speed and cost-efficiency
        $model = 'models/gemini-2.5-flash';

        $url = "{$this->baseUrl}/{$model}:generateContent?key={$this->apiKey}";

        //$strictInstruction = "Answer in Malay. Provide a concise answer in a numbered list. DO NOT PROVIDE EXPLANATIONS FOR EACH ITEM. START THE ANSWER IMMEDIATELY WITH NUMBER 1. DO NOT PROVIDE ANY INTRODUCTION OR PREAMBLE.";
        
        // Combine the strict instruction with the user's question
        $combinedPrompt = $strictInstruction . " Pertanyaan pengguna: " . $userMessage;

        // Define max output tokens (This is correct to control length)
         $maxTokens = 500;

        $body = [
            'contents' => [
                [
                    'role' => 'user', 
                    'parts' => [['text' => $combinedPrompt]]
                ]
            ],

            'generationConfig' => [
                'maxOutputTokens' => $maxTokens, 
            ],
            
            'tools' => [
                [
                    'file_search' => [ 
                    // Use snake_case for the store name list and wrap $storeName in an array
                        'file_search_store_names' => [$storeName] 
                    ]
                ]
            ]
        ];

        $response = Http::withHeaders(['Content-Type' => 'application/json'])
            ->post($url, $body);

        if ($response->failed()) {
            Log::error('Gemini Final RAG Status', [
                'status' => $response->status(),
                'body' => $response->json(),
                'store_id_used' => $storeName, // Log the actual ID being sent
            ]);
            // Fallback or throw error
            return "Respon RAG gagal diterima.";
        }

        $rawText = $response->json()['candidates'][0]['content']['parts'][0]['text'] ?? '';

        // --- START: Response Reformatting/Cleanup ---
        
        // 1. Remove unnecessary leading/trailing whitespace (spaces, newlines)
        $cleanText = trim($rawText);

        // 2. Remove common prefixes sometimes generated by RAG/AI models
        //    e.g., "The documents state:", "Jawapan:", "Ringkasan:"
        $prefixesToRemove = [
            'Jawapan:', 'Ringkasan:', 'Di sini ringkasan:', 
            'Here is a summary:', 'Based on the documents:'
        ];
        
        foreach ($prefixesToRemove as $prefix) {
            // Use case-insensitive search and remove only if it appears at the start
            if (stripos($cleanText, $prefix) === 0) {
                $cleanText = substr($cleanText, strlen($prefix));
                $cleanText = trim($cleanText); // Re-trim after removal
                break; // Stop checking after the first match
            }
        }
        
        // 3. Simple final check if text is empty after cleaning (should not happen often)
        if (empty($cleanText)) {
            return 'Respon kosong';
        }
        
        return $cleanText;
    }

    /**
     * 2. UPLOAD: Uploads a file AND links it to a specific Store
     */
    public function uploadAndIndexFile($storeName, $filePath, $mimeType, $customDisplayName) // ADDED $customDisplayName
    {
        $fileSize = filesize($filePath);
        // CHANGE: Use the custom display name instead of basename($filePath)
        $displayName = $customDisplayName; 

        // --- A. Initial Resumable Upload Request ---
        // We ask Google for a unique upload URL
        $initResponse = Http::withHeaders([
            'X-Goog-Upload-Protocol' => 'resumable',
            'X-Goog-Upload-Command' => 'start',
            'X-Goog-Upload-Header-Content-Length' => $fileSize,
            'X-Goog-Upload-Header-Content-Type' => $mimeType,
            'Content-Type' => 'application/json',
        ])->post("https://generativelanguage.googleapis.com/upload/v1beta/files?key={$this->apiKey}", [
            'file' => ['displayName' => $displayName]
        ]);
        // ... (rest of A, B, C steps are unchanged) ...

        if ($initResponse->failed()) {
            // ... (error handling) ...
            throw new \Exception("Failed to initialize upload.");
        }

        $uploadUrl = $initResponse->header('X-Goog-Upload-URL');

        // --- B. Perform the actual byte upload ---
        $fileContent = file_get_contents($filePath);
        
        $uploadResponse = Http::withHeaders([
            'Content-Length' => $fileSize,
            'X-Goog-Upload-Offset' => '0',
            'X-Goog-Upload-Command' => 'upload, finalize',
        ])->withBody($fileContent, $mimeType)->post($uploadUrl);

        if ($uploadResponse->failed()) {
            // ... (error handling) ...
            throw new \Exception("Failed to upload file bytes.");
        }

        $uploadedFile = $uploadResponse->json()['file']; // We get back the file object
        $geminiFileName = $uploadedFile['name']; // SAVE THIS! (e.g., files/abc123xyz)

        // --- C. Link the file to your Vector Store ---
        $importUrl = "{$this->baseUrl}/{$storeName}:importFile?key={$this->apiKey}";
        
        $linkResponse = Http::post($importUrl, [
            'file_name' => $geminiFileName
        ]);
        
        $operationName = $linkResponse->json()['name']; 
        if (!$operationName) {
            throw new \Exception("Failed to initiate indexing operation.");
        }

        // --- D. Wait for Indexing to Complete (LRO Polling) ---
        $maxAttempts = 30;
        $delaySeconds = 10; 

        for ($i = 0; $i < $maxAttempts; $i++) {
            sleep($delaySeconds);
            
            $statusUrl = "{$this->baseUrl}/{$operationName}?key={$this->apiKey}";
            $statusResponse = Http::get($statusUrl);

            if ($statusResponse->failed() || ($statusResponse->json()['error'] ?? false)) {
                // ... (error handling) ...
                throw new \Exception("RAG Indexing failed during operation check.");
            }
            
            if (($statusResponse->json()['done'] ?? false) === true) {
                $responseBody = $statusResponse->json();
                
                // 1. Get the document name from the LRO response payload (as seen in the log)
                // The structure is: response -> response -> documentName
                $documentNameSuffix = $responseBody['response']['documentName'] ?? null;
                
                if (empty($documentNameSuffix)) {
                    // Log the full response body to debug if the structure changes again
                    Log::error("Gemini Document Name Missing After Success", ['response' => $responseBody]);
                    throw new \Exception("RAG Indexing successful, but document name could not be found in response.");
                }

                // 2. Construct the full Document Resource Name
                // The LRO only returns the suffix (e.g., '1c3uggtch3t5-zfunmpxcocry').
                // We must prepend the store name path to get the full name needed for the DB and deletion.
                $fullDocumentName = "{$storeName}/documents/{$documentNameSuffix}";

                Log::info("RAG Indexing complete for file: " . $displayName);

                // RETURN THE CRITICAL IDs AND METADATA
                return [ 
                    'gemini_document_name' => $fullDocumentName, // Use the full constructed name
                    'gemini_file_name' => $geminiFileName,
                    'size_bytes' => $fileSize,
                ];
            }
        }

        throw new \Exception("RAG Indexing timed out after " . ($maxAttempts * $delaySeconds) . " seconds.");
    }

    //SETUP
    public function createStore($displayName = 'LMS Global Store')
    {
        $response = Http::post("{$this->baseUrl}/fileSearchStores?key={$this->apiKey}", [
            'displayName' => $displayName
        ]);
        
        return $response->json()['name'] ?? null; 
    }

    public function listFiles(){
        $storePath = $this->storeName;
        if (strpos($storePath, 'fileSearchStores/') === false) {
            $storePath = "fileSearchStores/{$storePath}";
        }

        $url = "{$this->baseUrl}/{$storePath}/documents?pageSize=20&key={$this->apiKey}";
        $response = Http::get($url);

        if ($response->failed()) return collect([]);

        $apiDocuments = $response->json()['documents'] ?? [];
        
        // Fetch local materials to map display names
        $localMaterials = \App\Models\ChatbotMaterial::all()->keyBy('gemini_document_name');

        return collect($apiDocuments)->map(function ($doc) use ($localMaterials) {
            $docName = $doc['name'];
            // Match API 'name' with local 'gemini_document_name'
            $local = $localMaterials->get($docName);

            return [
                'name' => $docName, 
                'display_name' => $local ? $local->display_name : $doc['displayName'], // Prioritize local name
                'gemini_internal_name' => $doc['displayName'] ?? 'N/A', // The random ID from Gemini
                'mime_type' => $doc['mimeType'] ?? null,
                'size_bytes' => (int)($doc['sizeBytes'] ?? 0),
                'created_at' => isset($doc['createTime']) ? \Carbon\Carbon::parse($doc['createTime'])->diffForHumans() : null,
                'state' => $doc['state'] ?? null,
            ];
        });
    }
    // Remove a file from the knowledge base
    public function deleteFile($fileName) {
        // $url = "{$this->baseUrl}/{$fileName}?key={$this->apiKey}";
        
        // $response = Http::delete($url);
        
        // if ($response->failed()) {
        //     Log::error('Gemini Delete Failed', $response->json());
        //     return false;
        // }

        // return true;

        // $fileName should be in the format: "files/{file_id}"
        // Deleting the File resource will automatically delete any associated Documents.

        $url = "{$this->baseUrl}/{$fileName}?key={$this->apiKey}&force=true";
        
        // This is a standard DELETE request. The Gemini API does not use a "--force" 
        // flag; that concept applies to command-line interfaces.
        $response = Http::delete($url);
        
        if ($response->failed()) {
            Log::error('Gemini Delete Failed', [
                'endpoint' => $url,
                'status' => $response->status(),
                'body' => $response->json(),
            ]);
            
            // Check for specific error status codes (e.g., 404 Not Found)
            if ($response->status() === 404) {
                 // A 404 means the file may have already been deleted or the name is wrong.
                 // We can consider this a successful removal for an idempotent operation.
                 Log::warning('Gemini Delete: Resource not found (404). Considering successful removal.', ['file' => $fileName]);
                 return true;
            }

            return false;
        }

        // The DELETE response body is typically empty on success (HTTP 200/204)
        Log::info('Gemini File successfully deleted.', ['file' => $fileName]);

        return true;
    }
}